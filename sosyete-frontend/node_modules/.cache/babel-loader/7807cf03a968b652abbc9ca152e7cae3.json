{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks static-only\n * @providesModule ReactTransitionChildMapping\n */\n'use strict';\n\nvar ReactChildren = require(\"./ReactChildren\");\n\nvar ReactFragment = require(\"./ReactFragment\");\n\nvar ReactTransitionChildMapping = {\n  /**\n   * Given `this.props.children`, return an object mapping key to child. Just\n   * simple syntactic sugar around ReactChildren.map().\n   *\n   * @param {*} children `this.props.children`\n   * @return {object} Mapping of key to child\n   */\n  getChildMapping: function (children) {\n    if (!children) {\n      return children;\n    }\n\n    return ReactFragment.extract(ReactChildren.map(children, function (child) {\n      return child;\n    }));\n  },\n\n  /**\n   * When you're adding or removing children some may be added or removed in the\n   * same render pass. We want to show *both* since we want to simultaneously\n   * animate elements in and out. This function takes a previous set of keys\n   * and a new set of keys and merges them with its best guess of the correct\n   * ordering. In the future we may expose some of the utilities in\n   * ReactMultiChild to make this easy, but for now React itself does not\n   * directly have this concept of the union of prevChildren and nextChildren\n   * so we implement it here.\n   *\n   * @param {object} prev prev children as returned from\n   * `ReactTransitionChildMapping.getChildMapping()`.\n   * @param {object} next next children as returned from\n   * `ReactTransitionChildMapping.getChildMapping()`.\n   * @return {object} a key set that contains all keys in `prev` and all keys\n   * in `next` in a reasonable order.\n   */\n  mergeChildMappings: function (prev, next) {\n    prev = prev || {};\n    next = next || {};\n\n    function getValueForKey(key) {\n      if (next.hasOwnProperty(key)) {\n        return next[key];\n      } else {\n        return prev[key];\n      }\n    } // For each key of `next`, the list of keys to insert before that key in\n    // the combined list\n\n\n    var nextKeysPending = {};\n    var pendingKeys = [];\n\n    for (var prevKey in prev) {\n      if (next.hasOwnProperty(prevKey)) {\n        if (pendingKeys.length) {\n          nextKeysPending[prevKey] = pendingKeys;\n          pendingKeys = [];\n        }\n      } else {\n        pendingKeys.push(prevKey);\n      }\n    }\n\n    var i;\n    var childMapping = {};\n\n    for (var nextKey in next) {\n      if (nextKeysPending.hasOwnProperty(nextKey)) {\n        for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n          var pendingNextKey = nextKeysPending[nextKey][i];\n          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n        }\n      }\n\n      childMapping[nextKey] = getValueForKey(nextKey);\n    } // Finally, add the keys which didn't appear before any key in `next`\n\n\n    for (i = 0; i < pendingKeys.length; i++) {\n      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n    }\n\n    return childMapping;\n  }\n};\nmodule.exports = ReactTransitionChildMapping;","map":{"version":3,"names":["ReactChildren","require","ReactFragment","ReactTransitionChildMapping","getChildMapping","children","extract","map","child","mergeChildMappings","prev","next","getValueForKey","key","hasOwnProperty","nextKeysPending","pendingKeys","prevKey","length","push","i","childMapping","nextKey","pendingNextKey","module","exports"],"sources":["/Users/ozigun1988/Desktop/git/project/sosyete-frontend/node_modules/react-upvote/node_modules/react/lib/ReactTransitionChildMapping.js"],"sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks static-only\n * @providesModule ReactTransitionChildMapping\n */\n\n'use strict';\n\nvar ReactChildren = require(\"./ReactChildren\");\nvar ReactFragment = require(\"./ReactFragment\");\n\nvar ReactTransitionChildMapping = {\n  /**\n   * Given `this.props.children`, return an object mapping key to child. Just\n   * simple syntactic sugar around ReactChildren.map().\n   *\n   * @param {*} children `this.props.children`\n   * @return {object} Mapping of key to child\n   */\n  getChildMapping: function(children) {\n    if (!children) {\n      return children;\n    }\n    return ReactFragment.extract(ReactChildren.map(children, function(child) {\n      return child;\n    }));\n  },\n\n  /**\n   * When you're adding or removing children some may be added or removed in the\n   * same render pass. We want to show *both* since we want to simultaneously\n   * animate elements in and out. This function takes a previous set of keys\n   * and a new set of keys and merges them with its best guess of the correct\n   * ordering. In the future we may expose some of the utilities in\n   * ReactMultiChild to make this easy, but for now React itself does not\n   * directly have this concept of the union of prevChildren and nextChildren\n   * so we implement it here.\n   *\n   * @param {object} prev prev children as returned from\n   * `ReactTransitionChildMapping.getChildMapping()`.\n   * @param {object} next next children as returned from\n   * `ReactTransitionChildMapping.getChildMapping()`.\n   * @return {object} a key set that contains all keys in `prev` and all keys\n   * in `next` in a reasonable order.\n   */\n  mergeChildMappings: function(prev, next) {\n    prev = prev || {};\n    next = next || {};\n\n    function getValueForKey(key) {\n      if (next.hasOwnProperty(key)) {\n        return next[key];\n      } else {\n        return prev[key];\n      }\n    }\n\n    // For each key of `next`, the list of keys to insert before that key in\n    // the combined list\n    var nextKeysPending = {};\n\n    var pendingKeys = [];\n    for (var prevKey in prev) {\n      if (next.hasOwnProperty(prevKey)) {\n        if (pendingKeys.length) {\n          nextKeysPending[prevKey] = pendingKeys;\n          pendingKeys = [];\n        }\n      } else {\n        pendingKeys.push(prevKey);\n      }\n    }\n\n    var i;\n    var childMapping = {};\n    for (var nextKey in next) {\n      if (nextKeysPending.hasOwnProperty(nextKey)) {\n        for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n          var pendingNextKey = nextKeysPending[nextKey][i];\n          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(\n            pendingNextKey\n          );\n        }\n      }\n      childMapping[nextKey] = getValueForKey(nextKey);\n    }\n\n    // Finally, add the keys which didn't appear before any key in `next`\n    for (i = 0; i < pendingKeys.length; i++) {\n      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n    }\n\n    return childMapping;\n  }\n};\n\nmodule.exports = ReactTransitionChildMapping;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,aAAa,GAAGC,OAAO,CAAC,iBAAD,CAA3B;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,iBAAD,CAA3B;;AAEA,IAAIE,2BAA2B,GAAG;EAChC;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,eAAe,EAAE,UAASC,QAAT,EAAmB;IAClC,IAAI,CAACA,QAAL,EAAe;MACb,OAAOA,QAAP;IACD;;IACD,OAAOH,aAAa,CAACI,OAAd,CAAsBN,aAAa,CAACO,GAAd,CAAkBF,QAAlB,EAA4B,UAASG,KAAT,EAAgB;MACvE,OAAOA,KAAP;IACD,CAF4B,CAAtB,CAAP;EAGD,CAf+B;;EAiBhC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,kBAAkB,EAAE,UAASC,IAAT,EAAeC,IAAf,EAAqB;IACvCD,IAAI,GAAGA,IAAI,IAAI,EAAf;IACAC,IAAI,GAAGA,IAAI,IAAI,EAAf;;IAEA,SAASC,cAAT,CAAwBC,GAAxB,EAA6B;MAC3B,IAAIF,IAAI,CAACG,cAAL,CAAoBD,GAApB,CAAJ,EAA8B;QAC5B,OAAOF,IAAI,CAACE,GAAD,CAAX;MACD,CAFD,MAEO;QACL,OAAOH,IAAI,CAACG,GAAD,CAAX;MACD;IACF,CAVsC,CAYvC;IACA;;;IACA,IAAIE,eAAe,GAAG,EAAtB;IAEA,IAAIC,WAAW,GAAG,EAAlB;;IACA,KAAK,IAAIC,OAAT,IAAoBP,IAApB,EAA0B;MACxB,IAAIC,IAAI,CAACG,cAAL,CAAoBG,OAApB,CAAJ,EAAkC;QAChC,IAAID,WAAW,CAACE,MAAhB,EAAwB;UACtBH,eAAe,CAACE,OAAD,CAAf,GAA2BD,WAA3B;UACAA,WAAW,GAAG,EAAd;QACD;MACF,CALD,MAKO;QACLA,WAAW,CAACG,IAAZ,CAAiBF,OAAjB;MACD;IACF;;IAED,IAAIG,CAAJ;IACA,IAAIC,YAAY,GAAG,EAAnB;;IACA,KAAK,IAAIC,OAAT,IAAoBX,IAApB,EAA0B;MACxB,IAAII,eAAe,CAACD,cAAhB,CAA+BQ,OAA/B,CAAJ,EAA6C;QAC3C,KAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGL,eAAe,CAACO,OAAD,CAAf,CAAyBJ,MAAzC,EAAiDE,CAAC,EAAlD,EAAsD;UACpD,IAAIG,cAAc,GAAGR,eAAe,CAACO,OAAD,CAAf,CAAyBF,CAAzB,CAArB;UACAC,YAAY,CAACN,eAAe,CAACO,OAAD,CAAf,CAAyBF,CAAzB,CAAD,CAAZ,GAA4CR,cAAc,CACxDW,cADwD,CAA1D;QAGD;MACF;;MACDF,YAAY,CAACC,OAAD,CAAZ,GAAwBV,cAAc,CAACU,OAAD,CAAtC;IACD,CAxCsC,CA0CvC;;;IACA,KAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGJ,WAAW,CAACE,MAA5B,EAAoCE,CAAC,EAArC,EAAyC;MACvCC,YAAY,CAACL,WAAW,CAACI,CAAD,CAAZ,CAAZ,GAA+BR,cAAc,CAACI,WAAW,CAACI,CAAD,CAAZ,CAA7C;IACD;;IAED,OAAOC,YAAP;EACD;AAlF+B,CAAlC;AAqFAG,MAAM,CAACC,OAAP,GAAiBtB,2BAAjB"},"metadata":{},"sourceType":"script"}